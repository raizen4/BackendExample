import { useReducer, useRef, useEffect, useLayoutEffect } from 'react';

const useIsoLayoutEffect = typeof window === 'undefined' ? useEffect : useLayoutEffect;
function create(createState) {
  let state;
  let listeners = new Set();

  const setState = partial => {
    const partialState = typeof partial === 'function' ? partial(state) : partial;

    if (partialState !== state) {
      state = Object.assign({}, state, partialState);
      listeners.forEach(listener => listener());
    }
  };

  const getState = () => state;

  const getSubscriber = (listener, selector = getState, equalityFn = Object.is) => ({
    currentSlice: selector(state),
    equalityFn,
    errored: false,
    listener,
    selector,
    unsubscribe: () => {}
  });

  const subscribe = subscriber => {
    function listener() {
      // Selector or equality function could throw but we don't want to stop
      // the listener from being called.
      // https://github.com/react-spring/zustand/pull/37
      try {
        const newStateSlice = subscriber.selector(state);

        if (!subscriber.equalityFn(subscriber.currentSlice, newStateSlice)) {
          subscriber.listener(subscriber.currentSlice = newStateSlice);
        }
      } catch (error) {
        subscriber.errored = true;
        subscriber.listener(null, error);
      }
    }

    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  };

  const apiSubscribe = (listener, selector, equalityFn) => subscribe(getSubscriber(listener, selector, equalityFn));

  const destroy = () => listeners.clear();

  const useStore = (selector = getState, equalityFn = Object.is) => {
    const forceUpdate = useReducer(c => c + 1, 0)[1];
    const subscriberRef = useRef();

    if (!subscriberRef.current) {
      subscriberRef.current = getSubscriber(forceUpdate, selector, equalityFn);
      subscriberRef.current.unsubscribe = subscribe(subscriberRef.current);
    }

    const subscriber = subscriberRef.current;
    let newStateSlice;
    let hasNewStateSlice = false; // The selector or equalityFn need to be called during the render phase if
    // they change. We also want legitimate errors to be visible so we re-run
    // them if they errored in the subscriber.

    if (subscriber.selector !== selector || subscriber.equalityFn !== equalityFn || subscriber.errored) {
      // Using local variables to avoid mutations in the render phase.
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(subscriber.currentSlice, newStateSlice);
    } // Syncing changes in useEffect.


    useIsoLayoutEffect(() => {
      if (hasNewStateSlice) {
        subscriber.currentSlice = newStateSlice;
      }

      subscriber.selector = selector;
      subscriber.equalityFn = equalityFn;
      subscriber.errored = false;
    });
    useIsoLayoutEffect(() => subscriber.unsubscribe, []);
    return hasNewStateSlice ? newStateSlice : subscriber.currentSlice;
  };

  const api = {
    setState,
    getState,
    subscribe: apiSubscribe,
    destroy
  };
  state = createState(setState, getState, api);
  return [useStore, api];
}

export default create;
export { create };
